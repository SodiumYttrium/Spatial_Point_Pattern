<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.433">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Natalie Young">
<meta name="dcterms.date" content="2023-08-23">
<meta name="description" content="Estimating the K-function. Thumbnail credit: ((ForestGEO), n.d.)">

<title>UROP - Spatial Point Patterns - Estimation of Second Order Properties</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">UROP - Spatial Point Patterns</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/SodiumYttrium/Spatial_Point_Pattern.git" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com" rel="" target=""><i class="bi bi-twitter" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Estimation of Second Order Properties</h1>
                  <div>
        <div class="description">
          Estimating the K-function. Thumbnail credit: <span class="citation" data-cites="BCIphoto">(<a href="#ref-BCIphoto" role="doc-biblioref">(ForestGEO), n.d.</a>)</span>
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">code</div>
                <div class="quarto-category">analysis</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Natalie Young </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">August 23, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<section id="estimating-the-k-function" class="level1">
<h1>Estimating the K-function</h1>
<p>Recall the definition of the K-function: <span class="math display">\[
K(t) = \frac{E[N_0(t)]}{\lambda}
\]</span> In small samples, estimation of <span class="math inline">\(K(t)\)</span> would be more straightforward than that of <span class="math inline">\(\lambda_2(t)\)</span> or <span class="math inline">\(\rho(t)\)</span>. While <span class="math inline">\(K(t)\)</span> and <span class="math inline">\(\lambda_2(t)\)</span> are both related to the distribution of inter-event distances, <span class="math inline">\(K(t)\)</span> can be estimated without deciding how much to smooth the empirical distribution.</p>
<p>Sometimes we may use random thinning (i.e.&nbsp;retaining or discarding each event using mutually independent Bernoulli trials) to reduce our sample size, and <span class="math inline">\(K(t)\)</span> is invariant under this process. This is due to the ratio of <span class="math inline">\(E[N_0(t)]\)</span> and <span class="math inline">\(\lambda\)</span> being unchanged.</p>
<p>An obvious estimator for <span class="math inline">\(\lambda\)</span> is <span class="math inline">\(\hat{\lambda} = n/|A|\)</span>, the number of observed events divided by the area. As for <span class="math inline">\(E[N_0(t)]\)</span>, the expected number of further events within distance <span class="math inline">\(t\)</span> of an arbitrary event, we can use the following estimator: <span class="math display">\[
\tilde{E}(t) = \frac{1}{n} \displaystyle \sum_{i=1}^n \sum_{j \ne i} I(r_{ij} \leq t)
\]</span> where <span class="math inline">\(I\)</span> is the indicator function and <span class="math inline">\(r_{ij} = ||x_i - x_j||\)</span>. However, this estimator is negatively biased due to <em>edge-effects</em>, where events outside of the observed region may interact with those within the region. In this case, some events that lie within distance <span class="math inline">\(t\)</span> may be unobserved as they lie outside the region.</p>
</section>
<section id="edge-correction" class="level1">
<h1>Edge-correction</h1>
<p>We will now explore the method <span class="citation" data-cites="Ripley">(<a href="#ref-Ripley" role="doc-biblioref">Ripley 1976</a>)</span> to correct this bias. Let <span class="math inline">\(w(x,r)\)</span> be the proportion of the circumference of the circle, with centre <span class="math inline">\(x\)</span> and radius <span class="math inline">\(r\)</span>, that lies in the observed region <span class="math inline">\(A\)</span>. Define <span class="math inline">\(w_{ij} = w(x_i, ||x_i-x_j||)\)</span>, i.e.&nbsp;for a circle centred at <span class="math inline">\(x_i\)</span> with <span class="math inline">\(x_j\)</span> lying on its circumference, the proportion of the circumference inside <span class="math inline">\(A\)</span>. For any stationary isotropic process, <span class="math inline">\(w_{ij}\)</span> is the probability that an event is observed, given it is distance <span class="math inline">\(r_{ij}=||x_i-x_j||\)</span> away from event <span class="math inline">\(x_i\)</span>. In general <span class="math inline">\(w_{ij}\ne w_{ji}\)</span>.</p>
<p>An unbiased estimator for <span class="math inline">\(E[N_0(t)]\)</span> is thus: <span class="math display">\[
\hat{E}(t)=\frac{1}{n}\displaystyle \sum_{i=1}^n\sum_{j \ne i}\frac{1}{w_{ij}}I(r_{ij} \leq t)
\]</span> Replacing the unknown intensity <span class="math inline">\(\lambda\)</span> by <span class="math inline">\((n-1)/|A|\)</span>, we obtain an estimator for <span class="math inline">\(K(t)\)</span>: <span class="math display">\[
\hat{K}(t)= \frac{|A|}{n(n-1)} \displaystyle \sum_{i=1}^n\sum_{j \ne i}\frac{1}{w_{ij}}I(r_{ij} \leq t)
\]</span> This is the form that Diggle used in the book. Ripley’s estimator used <span class="math inline">\(n^2\)</span> instead of <span class="math inline">\(n(n-1)\)</span> in the denominator, but for large <span class="math inline">\(n\)</span>, the difference is negligible.</p>
<p>The variance of <span class="math inline">\(\hat{K}(t)\)</span> can be used in a similar way to the simulation envelopes we used in previous CSR tests. There are several ways to estimate the sample variance, proposed by various people, but in particular, assuming <span class="math inline">\(A\)</span> is a rectangular region, Lotwick and Silverman’s result is <span class="citation" data-cites="LS">(<a href="#ref-LS" role="doc-biblioref">Lotwick and Silverman 1982</a>)</span>: <span class="math display">\[
v_{LS}(t) = \frac{1}{n(n-1)}\{2b(t)-a_1(t) + (n-2)a_2(t)\}
\]</span> where, denoting the perimeter of <span class="math inline">\(A\)</span> as <span class="math inline">\(P\)</span>, <span class="math display">\[
\begin{align}
b(t) &amp;= \frac{\pi t^2}{|A|} (1 - \frac{\pi t^2}{|A|}) + \frac{1}{|A|^2} (1.0716Pt^2
+ 2.2375t^4), \\
a_1(t) &amp;= \frac{1}{|A|^2}(0.21Pt^3 + 1.3t^4), \\
a_2(t) &amp;= \frac{1}{|A|^3}(0.24Pt^5 + 2.62t^6) \\
\end{align}
\]</span> The formulae have been modified by Diggle to account for the modified formula of <span class="math inline">\(\hat{K}(t)\)</span>. They are valid for <span class="math inline">\(t\)</span> at most the length of the shorter side of <span class="math inline">\(A\)</span>.</p>
</section>
<section id="estimation-using-r" class="level1">
<h1>Estimation using R</h1>
<p>RStudio has the built-in function <code>Kest</code> which estimates the K function and the variance, based on several edge-correction methods. Here we will use Ripley’s isotropic correction and Lotwick and Silverman’s variance under homogeneity, as they were discussed above. The following graphs will plot <span class="math inline">\(\hat{K}(t)\)</span> of the data, the theoretical <span class="math inline">\(K(t)\)</span> from a homogeneous Poisson process, and the envelopes that are <span class="math inline">\(K(t)\)</span> plus or minus 2 standard errors.</p>
<section id="japanese-black-pines" class="level2">
<h2 class="anchored" data-anchor-id="japanese-black-pines">Japanese black pines</h2>
<div class="cell">
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-3-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>We see that <span class="math inline">\(\hat{K}(t)\)</span> lies close to <span class="math inline">\(K(t)\)</span>, and remains inside the envelopes. CSR is evident, which agrees with our previous tests of CSR.</p>
</section>
<section id="redwood" class="level2">
<h2 class="anchored" data-anchor-id="redwood">Redwood</h2>
<div class="cell">
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-4-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>With the majority proportion of <span class="math inline">\(\hat{K}(t)\)</span> lying above 2 standard errors of <span class="math inline">\(K(t)\)</span>, it is clear that the data is aggregated, since there are more further events expected around an arbitrary event compared to a homogeneous Poisson process.</p>
</section>
<section id="cells" class="level2">
<h2 class="anchored" data-anchor-id="cells">Cells</h2>
<div class="cell">
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-5-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>For distances under 0.15, the expected number of further events around an arbitrary event is less than under CSR. This is a typical behaviour of regular patterns, and this agrees with our previous tests of CSR.</p>
</section>
<section id="beilschmiedia-pendula-lauraceae" class="level2">
<h2 class="anchored" data-anchor-id="beilschmiedia-pendula-lauraceae">Beilschmiedia pendula (Lauraceae)</h2>
<p>Since the built-in function is not suitable for handling patterns with over 3000 data points, I am only performing the test on the top left corner of the region, which is a <span class="math inline">\(100 \times 100\)</span> square containing 136 points:</p>
<div class="cell">
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-6-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-7-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>The clear excess of expected further events provides strong evidence against CSR. We have established from previous CSR tests that the pattern of all 3604 trees are aggregated just like the redwood saplings, and this subset behaves the same.</p>
</section>
</section>
<section id="multivariate-process" class="level1">
<h1>Multivariate process</h1>
<p>The estimation of <span class="math inline">\(K_{12}(t)\)</span> for a bivariate pattern follows the same idea as <span class="math inline">\(K(t)\)</span>, but the distances measured would be between pairs of events of different types. For the <span class="math inline">\(i\)</span>th type 1 event and the <span class="math inline">\(j\)</span>th type 2 event, let <span class="math inline">\(u_{ij}\)</span> be the distance between them, and <span class="math inline">\(w_{ij}\)</span> be defined based on them. The numbers of type 1 and 2 events are <span class="math inline">\(n_1\)</span> and <span class="math inline">\(n_2\)</span> respectively. Then a weighted average of estimated <span class="math inline">\(\hat{K}_{12}(t)\)</span> would be:</p>
<p><span class="math display">\[
\hat{K}_{12}(t) = \frac{|A|}{n_1 n_2}\displaystyle \sum_{i=1}^{n_1} \sum_{j=1}^{n_2}
w_{ij}^* I(u_{ij} \le t)
\]</span> where <span class="math display">\[
w_{ij}^* = \frac{n_1 w_{ij} + n_2 w_{ji}}{n_1 + n_2}
\]</span> Lotwick and Silverman <span class="citation" data-cites="LS">(<a href="#ref-LS" role="doc-biblioref">Lotwick and Silverman 1982</a>)</span> also gave a formula for the variance of the bivariate case. For <span class="math inline">\(b(t)\)</span>, <span class="math inline">\(a_1(t)\)</span> and <span class="math inline">\(a_2(t)\)</span> as defined above, alongside <span class="math inline">\(c=n_2/(n_1+n_2)\)</span>, for 2 independent homogeneous Poisson processes, <span class="math display">\[
Var\{\hat{K}_{12}(t)\} = \frac{|A|^2}{n_1 n_2}[b(t) - 2c(1-c)a_1(t) + \{(n_1-1)c^2
+ (n_2-1)(1-c)^2\}a_2(t)]
\]</span></p>
<p>From the Barro Colorado Island dataset <span class="citation" data-cites="bciweb Condit bci">(<a href="#ref-bciweb" role="doc-biblioref">H. Condit R. and Foster 2005</a>; <a href="#ref-Condit" role="doc-biblioref">R. Condit 1998</a>; <a href="#ref-bci" role="doc-biblioref">Hubbell and Lao 1999</a>)</span>, I have obtained 3 species of trees: <em>Acalypha diversifolia</em>, <em>Cecropia insignis</em> and <em>Cupania seemannii</em>. Using the <code>Kmulti</code> built-in function, <span class="math inline">\(\hat{K}_{12}(t)\)</span> between each pair of these species can be estimated.</p>
<div class="cell">
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-9-1.png" class="img-fluid" width="672"></p>
</div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-9-2.png" class="img-fluid" width="672"></p>
</div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-9-3.png" class="img-fluid" width="672"></p>
</div>
</div>
<section id="acalypha-diversifolia-cecropia-insignis" class="level2">
<h2 class="anchored" data-anchor-id="acalypha-diversifolia-cecropia-insignis">Acalypha diversifolia &amp; Cecropia insignis</h2>
<div class="cell">
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-10-1.png" class="img-fluid" width="672"></p>
</div>
</div>
</section>
<section id="cecropia-insignis-cupania-seemannii" class="level2">
<h2 class="anchored" data-anchor-id="cecropia-insignis-cupania-seemannii">Cecropia insignis &amp; Cupania seemannii</h2>
<div class="cell">
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-11-1.png" class="img-fluid" width="672"></p>
</div>
</div>
</section>
<section id="cupania-seemannii-acalypha-diversifolia" class="level2">
<h2 class="anchored" data-anchor-id="cupania-seemannii-acalypha-diversifolia">Cupania seemannii &amp; Acalypha diversifolia</h2>
<div class="cell">
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-12-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>The first 2 pairs of species exhibit strong aggregation, while the third pair exhibits regularity.</p>



</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" role="list">
<div id="ref-bciweb" class="csl-entry" role="listitem">
Condit, Hubbell, R., and R. B. Foster. 2005. <span>“Barro Colorado Forest Census Plot Data.”</span> <a href="http://ctfs.si.edu/webatlas/datasets/bci" class="uri">http://ctfs.si.edu/webatlas/datasets/bci</a>.
</div>
<div id="ref-Condit" class="csl-entry" role="listitem">
Condit, R. 1998. <em>Tropical Forest Census Plots</em>. Springer-Verlag, Berlin; R.G. Landes Company, Georgetown, Texas.
</div>
<div id="ref-BCIphoto" class="csl-entry" role="listitem">
(ForestGEO), Forest Global Earth Observatory. n.d. <span>“Barro Colorado Island.”</span> <a href="https://www.flickr.com/photos/ctfs">https://www.flickr.com/photos/ctfs</a>.
</div>
<div id="ref-bci" class="csl-entry" role="listitem">
Hubbell, R. B. Foster, S. P., and S. Loo de Lao. 1999. <span>“Light Gap Disturbances, Recruitment Limitation, and Tree Diversity in a Neotropical Forest.”</span> <em>Science</em> 283: 554–57. <a href="https://doi.org/10.1126/science.283.5401.554">https://doi.org/10.1126/science.283.5401.554</a>.
</div>
<div id="ref-LS" class="csl-entry" role="listitem">
Lotwick, H. W., and B. W. Silverman. 1982. <span>“Methods for Analysing Spatial Processes of Several Types of Points.”</span> <em>Journal of the Royal Statistical Society: Series B (Methodological)</em> 44: 406–13. <a href="https://doi.org/10.1111/j.2517-6161.1982.tb01221.x">https://doi.org/10.1111/j.2517-6161.1982.tb01221.x</a>.
</div>
<div id="ref-Ripley" class="csl-entry" role="listitem">
Ripley, B. D. 1976. <span>“The Second-Order Analysis of Stationary Point Processes.”</span> <em>Journal of Applied Probability</em> 13: 255–66. <a href="https://doi.org/10.2307/3212829">https://doi.org/10.2307/3212829</a>.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>